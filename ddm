#!/bin/sh

VERSION='0.0.1'

SH='/usr/bin/env sh'
LN='/usr/bin/env ln -srf'
RMDIR='rmdir --ignore-fail-on-non-empty'

DOTFILES_GLOB='.[!.]*'

CREATED_DIR_CACHE='.created_dirs'
CREATED_LINKS_CACHE='.created_links'

RED='\e[31m'
BOLD='\e[1m'
GRAY='\e[90m'
WHITE='\e[0m'
GREEN='\e[32m'
YELLO='\e[33m'

VERBOSE=0
FORCE=0

usage() {
cat << EOF
ddm version $VERSION

usage: ddm <command> [<args>]

DESCRIPTION
    Ddm is a useful tool for deploying and syncing user local
    configurations/dotfiles.

SUBCOMMANDS:
    install      Install application configurations
    uninstall    Remove installed application configurations

OPTIONS:
    -f    Do not prompt for file conflicts 
    -v    Increase verbosity to debug levels
    -h    Show this help
EOF
}

info() {
    if [ "$VERBOSE" -gt 0 ]; then
        printf '%b[ info ]%b %s\n' "$GRAY" "$WHITE" "$1" 
    fi
}

warn() {
    printf '%b[ warn ]%b %s\n' "$YELLO" "$WHITE" "$1"
}

error() {
    printf '%b[ erro ]%b %s\n' "$RED" "$WHITE" "$1"
}

# manual conflict resolution prompt to resolve conflicts
# with files that exist where a symlink is going to be
# placed
# $1 - The location of the file that produced the collision
# return - 0 for overwrite, 1 for keeping the original
conflict() {
    warn 'conflict detected at '"$1"' do you want to overwrite (Y/n)? [Y] '
    choice='y'
    read -r choice
    case $choice in
        [Yy]*) return 0 ;;
        [Nn]*) return 1 ;;
    esac
}

# takes a given application name and returns whether or not it can
# be installed; looks in the current directory for properly
# formatted application folder according to spec.
#
# $1 - the name of the application to verify
can_install() {
    # locate the installation approval script
    verify_script="$1"'/inst.sh'

    if [ -x "$verify_script" ]; then
        if $SH "$verify_script"; then
            return 0
        fi
    else
        if [ -n "$(command -v "$appname")" ]; then
            return 0
        fi
    fi
    return 1
}

# installs the configuration files for the given input application
# based on the `meta` file location in the given application's
# folder according to the spec. searches current directory.
#
# $1 - the name of the application to install
install_config() {
    # find meta script directory
    meta_script="$1"'/meta'

    # setup default install variables
    install_dir="$HOME""/.config/""$1"

    if [ -x "$meta_script" ]; then
        # shellcheck disable=SC1090
        . "$meta_script"
    fi

    # notify user about the installation of the dotfiles for the given application
    info 'installing dotfiles for "'"$appname"'" to "'"$install_dir"'"'

    # make sure config files exist
    conf_files_location="$1"'/conf'
    if [ ! -d "$conf_files_location" ]; then
        warn 'could not find config files for application '"$1"
        return 1
    fi

    # create install dir if it doesn't exist
    if [ ! -d "$install_dir" ]; then
        info 'creating installation directory "'"$install_dir"'"'
        mkdir -p "$install_dir" || { error 'could not create install directory'; return 1; }
        echo "$install_dir" >> "$CREATED_DIR_CACHE" 
    fi

    # collect all of the dotfiles that we need to install
    local_dotfiles_glob="$conf_files_location"'/'"$DOTFILES_GLOB"
    for f in $local_dotfiles_glob; do conf_files="$conf_files"' '"$f"; done
    if [ "${conf_files# }" = "$local_dotfiles_glob" ]; then conf_files=''; fi

    # collect any additional files that we need to install
    local_otherfiles_glob="$conf_files_location"'/'"*"
    for f in $local_otherfiles_glob; do conf_files="$conf_files"' '"$f"; done
    if [ "${conf_files# }" = "$local_otherfiles_glob" ]; then conf_files=''; fi

    # iterate through files linking to the right location
    for to_copy in $conf_files; do
        destination="$install_dir"'/'"$(basename "$to_copy")"

        if [ -e "$destination" ]; then
            info 'destination "'"$destination"'" already exists - conflict'

            if [ "$FORCE" -gt 0 ]; then
                info 'force enabled; skipping "'"$destination"'"'
            else
                if ! conflict "$destination"; then
                    info 'skipping "'"$(basename "$to_copy")"'"'
                    continue
                fi
            fi
        fi

        info 'linking "'"$(basename "$to_copy")"'" to "'"$destination"'"'
        $LN "$to_copy" "$install_dir" || error 'cannot create symlink to '"$destination" 

        echo "$destination" >> "$CREATED_LINKS_CACHE"
    done
}

# installs all application packages in the given directory by first
# checking if they can be installed, then runnning the install
# command on them
install() {
    for folder in */; do
        appname="${folder%/}"

        if can_install "$appname"; then
            info 'installing '"$appname"
            install_config "$appname"
        else
            warn 'cannot install '"$appname"
        fi
    done
}

# uses the corresponding cache files to remove the installed
# symlinks and folders, first removing the symlinks, then removing
# the empty folders that remain (and leaving the ones that aren't
# empty)
uninstall() {
    # if no cache files exist we should warn the user about it and exit
    if [ ! -f "$CREATED_LINKS_CACHE" ] && [ ! -f "$CREATED_DIR_CACHE" ]; then
        warn 'cache files do not exist; are you sure you installed?'
        return 1
    fi

    # remove cached created symlinks
    if [ -f "$CREATED_LINKS_CACHE" ]; then
        # shellcheck disable=SC2013
        for created_symlink in $(cat "$CREATED_LINKS_CACHE"); do
            if [ -e "$created_symlink" ]; then
                info 'removing symlink "'"$created_symlink"'"'
                rm "$created_symlink"
            fi
        done
    fi


    # remove empty created folders
    if [ -f "$CREATED_DIR_CACHE" ]; then
        # shellcheck disable=SC2013
        for created_folder in $(cat "$CREATED_DIR_CACHE"); do
            info 'removing directory "'"$created_folder"'" if empty'
            $RMDIR "$created_folder"
        done
    fi

    rm -f "$CREATED_DIR_CACHE" "$CREATED_LINKS_CACHE"
}

# check the number of arguments
if [ $# -lt 1 ]; then
    usage
    exit 1
fi

if [ "$1" = '-h' ] || [ "$1" = '--help' ]; then
    usage
    exit 0
fi

# parse command line options
subcommand=$1; shift
while getopts "fvVh" opt; do
    case $opt in
        f )
            FORCE=1
        ;;
        v )
            VERBOSE=1
        ;;
        h )
            usage
            exit 0
        ;;
        ? )
            error 'unrecognized flag passed in'
            exit 1
        ;;
    esac
done

# process subcommands
if [ "$subcommand" = "install" ]; then
    install
elif [ "$subcommand" = "uninstall" ]; then
    uninstall
else
    error 'unrecognized subcommand! please use a valid subcommand'
    usage
fi
