#!/bin/sh

VERSION='0.0.1'

SH='/usr/bin/env sh'
LN='/usr/bin/env ln -srf'
RMDIR='rmdir --ignore-fail-on-non-empty'

DOTFILES_GLOB='.[!.]*'

CREATED_DIR_CACHE='.created_dirs'
CREATED_LINKS_CACHE='.created_links'

RED='\e[31m'
BOLD='\e[1m'
GRAY='\e[90m'
WHITE='\e[0m'
GREEN='\e[32m'
YELLO='\e[33m'

VERBOSE=0
FORCE=0

usage() {
cat << EOF
ddm version $VERSION

usage: ddm <command> [<args>]

DESCRIPTION
    Ddm is a useful tool for deploying and syncing user local
    configurations/dotfiles.

COMMANDS:
    install      Install application configurations
    uninstall    Remove installed application configurations

OPTIONS:
    -f    Do not prompt for file conflicts 
    -v    Increase verbosity to debug levels
    -h    Show this help
EOF
}

################################################################################

info() {
    if [ "$VERBOSE" -gt 0 ]; then
        printf '%b[ info ]%b %s\n' "$GRAY" "$WHITE" "$1" 
    fi
}

warn() {
    printf '%b[ warn ]%b %s\n' "$YELLO" "$WHITE" "$1"
}

error() {
    printf '%b[ erro ]%b %s\n' "$RED" "$WHITE" "$1"
}

################################################################################

# takes a file glob and a directory; returns the files that match that glob in
# the directory separated by spaces al-la posix sh 'arrays'
# 
# $1     - the directory in which to search
# $2     - the glob to use in the directory
# return - sh 'array' of the files that match the glob

collect_file_glob() {
    collected_files=''
    path_glob="$1"'/'"$2"

    for file in $path_glob; do
        collected_files="$collected_files"' '"$file"
    done

    if [ ! "${file# }" = "$path_glob" ]; then
        printf '%s' "$collected_files"
    else
        printf ''
    fi
}

# manual conflict resolution prompt to resolve conflicts with files that exist
# where a symlink is going to be placed
#
# $1     - the location of the file that produced the collision
#              (used for printing purposes)
# return - 0 for overwrite, 1 for keeping the original

prompt_conflict() {
    warn 'conflict detected at '"$1"' do you want to overwrite (Y/n)? [Y] '
    choice='y'
    read -r choice
    case $choice in
        [Yy]*) return 0 ;;
        [Nn]*) return 1 ;;
    esac
}

# pre-emptive conflict detection and elimination function; checks whether or not
# a file exists at a destination; if the file does exist it prompts the user to
# overwrite it.
#
# $1     - the destination file to check
# return - 0 for a successful resolution, 1 if a conflict could 
#          not be resolved and a symlink cannot be created 

detect_resolve_conflict() {
    if [ -e "$1" ]; then
        if [ "$FORCE" -gt 0 ]; then
            warn "force enabled overriding '""$1""' with symlink"
            return 0
        else
            if ! prompt_conflict "$1"; then
                info "skipping '""$(basename "$to_copy")""'"
                return 1
            fi
        fi
    fi
}

# created a symlink with the defined $LN while logging in the designated symlink
# log file (designated by $CREATED_LINKS_CACHE).
#
# $1     - the source directory/file
# $2     - the destination directory/file
# return - 0 for link success, 1 for failure

logged_ln() {
    filename="$(basename "$1")"
    full_dest="$2"'/'"$filename"

    info "linking '""$1""' to '""$2"

    if $LN "$1" "$2"; then
        echo "$full_dest" >> "$CREATED_LINKS_CACHE"
        return 0
    else
        error 'cannot create symlink in '"$2" 
        return 1
    fi 
}

# create a directory if it doesn't exist and notify the user with the info
# command.
#
# $1     - the path of the directory to create
# return - 0 for lack of failure, 1 for failure

create_dir_if_not_exists() {
    if [ ! -d "$1" ]; then
        info "creating '""$1""' to store config files" 

        if mkdir -p "$1"; then
            echo "$1" >> "$CREATED_DIR_CACHE" 
            return 0
        else
            error "could not create install directory '""$1""'"
            return 1
        fi
    fi
    return 0
}

################################################################################

# takes a given application name and returns whether or not it can be installed;
# looks in the current directory for properly formatted application folder
# according to spec.
#
# $1     - the name of the application to verify
# return - 0 if the application meets the criterion for install,
#          1 otherwise

can_install() {
    # locate the installation approval script
    verify_script="$1"'/inst.sh'

    if [ -x "$verify_script" ]; then
        if $SH "$verify_script"; then
            return 0
        fi
    else
        if [ -n "$(command -v "$appname")" ]; then
            return 0
        fi
    fi
    return 1
}

# installs the configuration files for the given input application based on the
# `meta` file location in the given application's folder according to the spec.
# searches current directory.
#
# $1     - the name of the application to install
# return - 0 for a successful install, 1 for any error

install_config() {
    # find meta script directory
    meta_script="$1"'/meta'

    # setup default install variables
    install_dir="$HOME""/.config/""$1"

    if [ -x "$meta_script" ]; then
        # shellcheck disable=SC1090
        . "$meta_script"
    fi

    info "installing dotfiles for '""$1""' to '""$install_dir""'"

    # make sure config files exist
    conf_files_location="$1"'/conf'
    if [ ! -d "$conf_files_location" ]; then
        warn 'could not find config files for application '"$1"
        return 1
    fi

    if ! create_dir_if_not_exists "$install_dir"; then
        return 1;
    fi

    # intit var for valid configuration files
    conf_files=''

    conf_files="$(collect_file_glob "$conf_files_location" "$DOTFILES_GLOB")"
    conf_files="$conf_files""$(collect_file_glob "$conf_files_location" '*')"

    # iterate through files linking to the right location
    for to_copy in $conf_files; do
        to_copy_name="$(basename "$to_copy")"
        destination="$install_dir"'/'"$to_copy_name"

        if ! detect_resolve_conflict "$destination"; then
            continue
        fi

        logged_ln "$to_copy" "$install_dir"
    done
}

# installs all application packages in the given directory by first checking if
# they can be installed, then running the install_config command on them; this
# is the main driver behind all application configuration installation
install() {
    for folder in */; do
        if [ "$folder" = '*' ]; then
            return 1
        fi

        appname="${folder%/}"

        if can_install "$appname"; then
            install_config "$appname"
        else
            warn "skipping '""$appname""'; not applicable"
        fi
    done
}

# uses the corresponding cache files to remove the installed symlinks and
# folders, first removing the symlinks, then removing the empty folders that
# remain (and leaving the ones that aren't empty)
uninstall() {
    # if no cache files exist we should warn the user about it and exit
    if [ ! -f "$CREATED_LINKS_CACHE" ] && [ ! -f "$CREATED_DIR_CACHE" ]; then
        warn 'cache files do not exist; are you sure you installed?'
        return 1
    fi

    # remove cached created symlinks
    if [ -f "$CREATED_LINKS_CACHE" ]; then
        # shellcheck disable=SC2013
        for created_symlink in $(cat "$CREATED_LINKS_CACHE"); do
            if [ -e "$created_symlink" ]; then
                info 'removing symlink "'"$created_symlink"'"'
                rm "$created_symlink"
            fi
        done
    fi


    # remove empty created folders
    if [ -f "$CREATED_DIR_CACHE" ]; then
        # shellcheck disable=SC2013
        for created_folder in $(cat "$CREATED_DIR_CACHE"); do
            info 'removing directory "'"$created_folder"'" if empty'
            $RMDIR "$created_folder"
        done
    fi

    rm -f "$CREATED_DIR_CACHE" "$CREATED_LINKS_CACHE"
}

################################################################################

# print usage info with no arguments 
if [ $# -lt 1 ]; then usage && exit 1; fi

# help shortcut - subcommand processing would ordinarily prevent help flags 
if [ "$1" = '-h' ] || [ "$1" = '--help' ]; then usage && exit 0; fi

# parse command line options
subcommand=$1; shift
while getopts "fvVh" opt; do
    case $opt in
        f )
            FORCE=1
        ;;
        v )
            VERBOSE=1
        ;;
        h )
            usage
            exit 0
        ;;
        ? )
            error 'Unknown option'
            usage
            exit 1
        ;;
    esac
done

# process subcommands
if [ "$subcommand" = "install" ]; then
    install
elif [ "$subcommand" = "uninstall" ]; then
    uninstall
else
    error "'""$subcommand""'"" is not a ddm command. See 'ddm -h'."
    exit 1
fi
