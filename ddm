#!/bin/sh

VERSION='0.0.1'

SH='/usr/bin/env sh'
LN='/usr/bin/env ln -srf'
RMDIR='rmdir --ignore-fail-on-non-empty'

CREATED_DIR_CACHE='.created_dirs'
CREATED_LINKS_CACHE='.created_links'

RED='\e[31m'
BOLD='\e[1m'
GRAY='\e[90m'
WHITE='\e[0m'
GREEN='\e[32m'
YELLO='\e[33m'

VERBOSE=0
FORCE=0

usage() {
cat << EOF
ddm version $VERSION

usage: ddm <command> [<args>]

DESCRIPTION
    Ddm is a useful tool for deploying and syncing user local
    configurations/dotfiles.

SUBCOMMANDS:
    install      Install application configurations
    uninstall    Remove installed application configurations
    generate     Generate a new application from a template

OPTIONS:
    -f    Do not prompt for file conflicts 
    -v    Increase verbosity to debug levels
    -h    Show this help
EOF
}

info() {
    if [ $VERBOSE -gt 0 ]; then
        printf '%b[ info ]%b %s\n' "$GRAY" "$WHITE" "$1" 
    fi
}

warn() {
    printf '%b[ warn ]%b %s\n' "$YELLO" "$WHITE" "$1"
}

error() {
    printf '%b[ erro ]%b %s\n' "$RED" "$WHITE" "$1"
}

# manual conflict resolution prompt to resolve conflicts
# with files that exist where a symlink is going to be
# placed
# $1 - The location of the file that produced the collision
# return - 0 for overwrite, 1 for keeping the original
conflict() {
    warn 'conflict detected at '"$1"' do you want to overwrite (Y/n)? [Y] '
    choice='y'
    read -r choice
    case $choice in
        [Yy]*) return 0 ;;
        [Nn]*) return 1 ;;
    esac
}

# takes a given application name and returns whether or not it can
# be installed; looks in the current directory for properly
# formatted application folder according to spec.
#
# $1 - the name of the application to verify
can_install() {
    # locate the installation approval script
    verify_script="$1"'/inst.sh'

    if [ -x "$verify_script" ]; then
        if $SH "$verify_script"; then
            return 0
        fi
    else
        if [ -n "$(command -v "$appname")" ]; then
            return 0
        fi
    fi
    return 1
}

# installs the configuration files for the given input application
# based on the `meta` file location in the given application's
# folder according to the spec. searches current directory.
#
# $1 - the name of the application to install
install_config() {
    # setup default install variables
    install_dir="$HOME""/.config/""$1"

    # execute meta overriding defaults
    meta_script="$1"'/meta'
    if [ -x "$meta_script" ]; then
        # shellcheck disable=SC1090
        . "$meta_script"
    fi

    # make sure config files exist
    conf_files_location="$1"'/conf'
    if [ ! -d "$conf_files_location" ]; then
        warn 'could not find config files for application '"$1"
        return 1
    fi

    # create install dir if it doesn't exist
    if [ ! -d "$install_dir" ]; then
        mkdir -p "$install_dir" || { error 'could not create install directory'; return 1; }
        echo "$install_dir" >> "$CREATED_DIR_CACHE" 
    fi

    conf_files="$conf_files_location"'/*'

    for to_copy in $conf_files; do
        destination="$install_dir"'/'"$(basename "$to_copy")"

        echo "$destination"

        go_ahead=0
        if [ -f "$destination" ]; then
            info 'destination "'"$destination"'" already exists - conflict'

            if [ "$FORCE" -gt 0 ]; then
                info 'force enabled; skipping "'"$destination"'"'
                go_ahead=1
            else
                if conflict "$destination"; then
                    go_ahead=1
                else
                    info 'skipping "'"$(basename "$to_copy")"'"'
                fi
            fi
        fi

        if [ "$go_ahead" -gt 0 ]; then
            $LN "$to_copy" "$install_dir" || error 'cannot create symlink to '"$to_copy" 
        fi


        echo "$destination" >> "$CREATED_LINKS_CACHE"
    done
}

# installs all application packages in the given directory by first
# checking if they can be installed, then runnning the install
# command on them
install() {
    for folder in */; do
        appname="${folder%/}"

        if can_install "$appname"; then
            info 'installing '"$appname"'...'
            install_config "$appname"
        else
            warn 'cannot install '"$appname"
        fi
    done
}

# uses the corresponding cache files to remove the installed
# symlinks and folders, first removing the symlinks, then removing
# the empty folders that remain (and leaving the ones that aren't
# empty)
uninstall() {
    # if no cache files exist we should warn the user about it and exit
    if [ ! -f "$CREATED_LINKS_CACHE" ] && [ ! -f "$CREATED_DIR_CACHE" ]; then
        warn 'cache files do not exist; are you sure you installed?'
        return 1
    fi

    # remove cached created symlinks
    if [ -f "$CREATED_LINKS_CACHE" ]; then
        # shellcheck disable=SC2013
        for created_symlink in $(cat "$CREATED_LINKS_CACHE"); do
            if [ -e "$created_symlink" ]; then
                rm "$created_symlink"
            fi
        done
    fi


    # remove empty created folders
    if [ -f "$CREATED_DIR_CACHE" ]; then
        # shellcheck disable=SC2013
        for created_folder in $(cat "$CREATED_DIR_CACHE"); do
            $RMDIR "$created_folder"
        done
    fi

    rm -f "$CREATED_DIR_CACHE" "$CREATED_LINKS_CACHE"
}

# check the number of arguments
if [ $# -lt 1 ]; then
    usage
    exit 1
fi

# parse command line options
subcommand=$1; shift
while getopts "fvVh" opt; do
    case $opt in
        f )
            FORCE=1
        ;;
        v )
            VERBOSE=1
        ;;
        h )
            usage
            exit 0
        ;;
        ? )
            error 'unrecognized flag passed in'
            exit 1
        ;;
    esac
done

# process subcommands
if [ "$subcommand" = "install" ]; then
    install
elif [ "$subcommand" = "uninstall" ]; then
    uninstall
else
    error 'unrecognized subcommand! please use a valid subcommand'
    usage
fi
