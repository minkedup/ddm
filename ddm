#!/usr/bin/env sh

VERSION='0.0.1'

SH='/usr/bin/env sh'
LN='/usr/bin/env ln -srf'
RMDIR='rmdir --parents --ignore-fail-on-non-empty'

DOTFILES_GLOB='.[!.]*'

CREATED_DIR_CACHE='.created_dirs'
CREATED_LINKS_CACHE='.created_links'

CURRENT_DIR_CACHE=''
CURRENT_LINKS_CACHE=''

RED='\e[31m'
BOLD='\e[1m'
GRAY='\e[90m'
WHITE='\e[0m'
GREEN='\e[32m'
YELLO='\e[33m'

VERBOSE=0
FORCE=0

usage() {
cat << EOF
ddm version $VERSION

usage: ddm <command> [<args>]

DESCRIPTION
    Ddm is a useful tool for deploying and syncing user local
    configurations/dotfiles.

COMMANDS:
    install      Install application configurations
    uninstall    Remove installed application configurations

OPTIONS:
    -f    Do not prompt for file conflicts 
    -v    Increase verbosity to debug levels
    -h    Show this help
EOF
}

############################## OUTPUT ##############################  

##
# prints info to the user if the global flag $VERBOSE is set
#
# @1 - the message to display to the user 
##
info() {
    if [ "$VERBOSE" -gt 0 ]; then
        printf '%b[ info ]%b %s\n' "$GRAY" "$WHITE" "$1" 
    fi
}

##
# warns the user that something may be wrong 
#
# @1 - the message to warn the user
##
warn() {
    printf '%b[ warn ]%b %s\n' "$YELLO" "$WHITE" "$1"
}

##
# displays an error to the user in red
#
# @1 - the error message to display
##
error() {
    printf '%b[ erro ]%b %s\n' "$RED" "$WHITE" "$1"
}

##
# prompts the user to resolve a file conflict
#
# the function prompts the user to overwrite a file, allowing the user to
# respond with Y\N with Y as a default. the function returns true if the user
# would like to overwrite the file, and false otherwise.
#
# @1      - the name of the file to prompt the user to overwrite 
# @return - true for overwrite, false for keeping the original
##
prompt_conflict() {
    warn 'conflict detected at '"$1"' do you want to overwrite (Y/n)? [Y] '
    choice='y'
    read -r choice
    case $choice in
        [Yy]*) return 0 ;;
        [Nn]*) return 1 ;;
    esac
}

############################## UTILITY ##############################  

#################### ARRAYS ####################  

##
# reads the given file into a space-separated string 'array'
#
# the function reads the given file into a string, replacing every encountered
# newline with a space. note: any spaces in the file will be interpreted as a
# new element in the 'array' 
#
# @1      - the file to read into an 'array'
# @return - the string 'array'
##
file_to_array() {
    filtered_content="$(tr '\n' ' ' < "$1")"

    printf '%s' "$filtered_content"
}

##
# checks whether or not a string is in an 'array'
#
# the function iterates through an 'array' of space separated elements and
# returns whether or not the given string is equal to any element in the 'array'
#
# @1      - the 'array' in which to search
# @2      - the string to search for in the 'array'
# @return - 0 if the string is in the 'array', 1 otherwise
##
in_array() {
    for element in $1; do
        if [ "$2" = "$element" ]; then
            return 0
        fi
    done
    return 1
}

##
# takes a file glob and a directory and returns the files that match the glob
# in the directory in the form of a space separated string.
# 
# @1      - the directory in which to search
# @2      - the glob to use in the directory
# @return - sh 'array' of the files that match the glob
##
collect_file_glob() {
    collected_files=''
    path_glob="$1"'/'"$2"

    for file in $path_glob; do
        collected_files="$collected_files"' '"$file"
    done

    if [ ! "${file# }" = "$path_glob" ]; then
        printf '%s' "$collected_files"
    else
        printf ''
    fi
}

#################### FILE SYSTEM ####################  

##
# preemptive conflict detection and resolution
#
# the function first checks whether or not a file exists at a given
# destination. if the file does exist, it then checks the global $FORCE flag
# and returns true if it's set. otherwise, it prompts the user to overwrite it,
# returning true if the user would like to overwrite it, otherwise returning
# false. 
#
# @1      - the destination file to check
# @return - 0 for a successful resolution, 1 if a conflict could 
##
resolve_file_conflict() {
    if [ -e "$1" ]; then
        if in_array "$CURRENT_LINKS_CACHE" "$1"; then
            info "skipping '""$(basename "$1")""'; already installed"
            return 1
        fi

        if [ "$FORCE" -gt 0 ]; then
            warn "force enabled overriding '""$1""' with symlink"
            return 0
        else
            if ! prompt_conflict "$1"; then
                info "skipping '""$(basename "$1")""'"
                return 1
            fi
        fi
    fi
}

##
# create a symlink with the globally defined $LN
#
# the function links a given source to a given destination, logging the
# operation to the console for the user to read as well as logging the created
# destination to ddm's cache files for later removals.
#
# @1      - source file's path 
# @2      - the destination path 
# @return - 0 for link success, 1 for failure
##
logged_ln() {
    filename="$(basename "$1")"
    full_dest="$2"'/'"$filename"

    info "linking '""$1""' to '""$2"

    if $LN "$1" "$2"; then
        echo "$full_dest" >> "$CREATED_LINKS_CACHE"
        return 0
    else
        error 'cannot create symlink in '"$2" 
        return 1
    fi 
}

##
# create a directory if it doesn't exist already
#
# the function creates a directory if it doesn't exist, logging the newly
# created directory in ddm's cache files for later removals. the function
# notifies the user that it has created a new directory.
#
# @1      - the path of the directory to create
# @return - 0 on success, 1 for creation failure
##
create_dir_if_not_exists() {
    if [ ! -d "$1" ]; then
        info "creating directory '""$1""' to store config files" 

        if mkdir -p "$1"; then
            echo "$1" >> "$CREATED_DIR_CACHE" 
            return 0
        else
            error "could not create install directory '""$1""'"
            return 1
        fi
    fi
    return 0
}

#################### FUNCTIONALITY ####################  

##
# loads cache files into the global variables for the cache files
##
load_cache_files() {
    if [ -e "$CREATED_DIR_CACHE" ]; then
        CURRENT_DIR_CACHE="$(file_to_array "$CREATED_DIR_CACHE")"
    fi

    if [ -e "$CREATED_LINKS_CACHE" ]; then
        CURRENT_LINKS_CACHE="$(file_to_array "$CREATED_LINKS_CACHE")"
    fi
}

##
# takes a given application name and returns whether or not it is a valid
# installation candidate 
#
# the function looks for an executable inst.sh file in the application directory
# relative to the current directory; if it finds the file, the function runs it
# with the global $SH, and returns its return value. otherwise, the function
# checks whether or not the application name is in the $PATH, and returns false
# if it cannot be found.
#
# @1      - the name of the application to verify
# @return - 0 if the application meets the criterion for install,
#           1 otherwise
##
can_install() {
    verify_script="$1"'/inst.sh'

    if [ -x "$verify_script" ]; then
        if $SH "$verify_script"; then
            return 0
        fi
    else
        if [ -n "$(command -v "$appname")" ]; then
            return 0
        fi
    fi
    return 1
}

##
# installs an application with its installation properties
#
# the function sets up default installation properties, then allows the
# application's meta file to override them; the function then installs the
# application
#
# @1      - the name of the application to install
# @return - 0 for a successful install, 1 for any error
##
install_config() {
    # find meta script directory
    meta_script="$1"'/meta'

    # setup default install variables
    install_dir="$HOME""/.config/""$1"

    if [ -x "$meta_script" ]; then
        # shellcheck disable=SC1090
        . "$meta_script"
    fi

    info "installing dotfiles for '""$1""' to '""$install_dir""'"

    # make sure config files exist
    conf_files_location="$1"'/conf'
    if [ ! -d "$conf_files_location" ]; then
        warn 'could not find config files for application '"$1"
        return 1
    fi

    # create/check existence of install directory
    if ! create_dir_if_not_exists "$install_dir"; then
        return 1;
    fi

    # init var for valid configuration files
    conf_files=''

    # normally globs don't match dotfiles - so we need two passes, once to 
    # pick up the dotfiles, another to pick up any other files
    conf_files="$(collect_file_glob "$conf_files_location" "$DOTFILES_GLOB")"
    conf_files="$conf_files""$(collect_file_glob "$conf_files_location" '*')"

    # iterate through files linking to the right location
    for to_copy in $conf_files; do
        to_copy_name="$(basename "$to_copy")"
        destination="$install_dir"'/'"$to_copy_name"

        if ! resolve_file_conflict "$destination"; then
            continue
        fi

        logged_ln "$to_copy" "$install_dir"
    done
}

############################## SUBCOMMANDS ##############################  

##
# installs all application packages in the given directory by first checking if
# they can be installed, then running the install_config command on them; this
# is the main driver behind all application configuration installation
##
install() {
    # load the cache file contents for redundancy checking
    load_cache_files

    for folder in */; do
        if [ "$folder" = '*' ]; then
            return 1
        fi

        appname="${folder%/}"

        if can_install "$appname"; then
            install_config "$appname"
        else
            warn "skipping '""$appname""'; not applicable"
        fi
    done
}

##
# uses the corresponding cache files to remove the installed symlinks and
# folders, first removing the symlinks, then removing the empty folders that
# remain (and leaving the ones that aren't empty)
##
uninstall() {
    # if no cache files exist we should warn the user about it and exit
    if [ ! -f "$CREATED_LINKS_CACHE" ] && [ ! -f "$CREATED_DIR_CACHE" ]; then
        warn 'cache files do not exist; are you sure you installed?'
        return 1
    fi

    # remove cached created symlinks
    if [ -f "$CREATED_LINKS_CACHE" ]; then
        # shellcheck disable=SC2013
        for created_symlink in $(cat "$CREATED_LINKS_CACHE"); do
            if [ -e "$created_symlink" ]; then
                info 'removing symlink "'"$created_symlink"'"'
                rm "$created_symlink"
            fi
        done
    fi


    # remove empty created folders
    if [ -f "$CREATED_DIR_CACHE" ]; then
        # shellcheck disable=SC2013
        for created_folder in $(cat "$CREATED_DIR_CACHE"); do
            info 'removing directory "'"$created_folder"'" if empty'
            $RMDIR "$created_folder"
        done
    fi

    rm -f "$CREATED_DIR_CACHE" "$CREATED_LINKS_CACHE"
}

############################## CLI PROCESSING ##############################  

# print usage info with no arguments 
if [ $# -lt 1 ]; then usage && exit 1; fi

# help shortcut - subcommand processing would ordinarily prevent help flags 
if [ "$1" = '-h' ] || [ "$1" = '--help' ]; then usage && exit 0; fi

# parse command line options
subcommand=$1; shift
while getopts "fvVh" opt; do
    case $opt in
        f )
            FORCE=1
        ;;
        v )
            VERBOSE=1
        ;;
        h )
            usage
            exit 0
        ;;
        ? )
            error 'Unknown option'
            usage
            exit 1
        ;;
    esac
done

# process subcommands
if [ "$subcommand" = "install" ]; then
    install
elif [ "$subcommand" = "uninstall" ]; then
    uninstall
else
    error "'""$subcommand""'"" is not a ddm command. See 'ddm -h'."
    exit 1
fi
