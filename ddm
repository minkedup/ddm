#!/usr/bin/env sh

VERSION='0.3.0'

CP='/usr/bin/env cp -Ln'
SH='/usr/bin/env sh'
LN='/usr/bin/env ln -srf'
RMDIR='rmdir --parents --ignore-fail-on-non-empty'

VALID_INSTALL_METHODS='symlink copy'

DOTFILES_GLOB='.[!.]*'

IGNORED_GLOBS_FILE='.ddmignore'
CREATED_DIRS_CACHE_FILE='.created_dirs'
CREATED_FILES_CACHE_FILE='.created_files'

IGNORED_GLOBS=''
CREATED_DIRS_CACHE=''
CREATED_FILES_CACHE=''

RED='\e[31m'
# shellcheck disable=SC2034
BOLD='\e[1m'
GRAY='\e[90m'
WHITE='\e[0m'
# shellcheck disable=SC2034
GREEN='\e[32m'
YELLO='\e[33m'

VERBOSE=0
FORCE=0

############################## OUTPUT ##############################  

##
# print usage information to the user
##
usage() {
cat << EOF
ddm version $VERSION

usage: ddm <command> [<args>]

DESCRIPTION
    Ddm is a useful tool for deploying and syncing user local
    configurations/dotfiles.

COMMANDS:
    install      Install application configurations
    uninstall    Remove installed application configurations

OPTIONS:
    -f    Do not prompt for file conflicts 
    -v    Increase verbosity to debug levels
    -h    Show this help
EOF
}

##
# prints info to the user if the global flag $VERBOSE is set
#
# @1 - the message to display to the user 
##
info() {
    if [ "$VERBOSE" -gt 0 ]; then
        printf '%b[ info ]%b %s\n' "$GRAY" "$WHITE" "$1" 
    fi
}

##
# warns the user that something may be wrong 
#
# @1 - the message to warn the user
##
warn() {
    printf '%b[ warn ]%b %s\n' "$YELLO" "$WHITE" "$1"
}

##
# displays an error to the user in red
#
# @1 - the error message to display
##
error() {
    printf '%b[ erro ]%b %s\n' "$RED" "$WHITE" "$1"
}

##
# prompts the user to resolve a file conflict
#
# the function prompts the user to overwrite a file, allowing the user to
# respond with Y\N with Y as a default. the function returns true if the user
# would like to overwrite the file, and false otherwise.
#
# @1      - the name of the file to prompt the user to overwrite 
# @return - true for overwrite, false for keeping the original
##
prompt_conflict() {
    warn 'conflict detected at '"$1"' do you want to overwrite (Y/n)? [Y] '
    choice='y'
    read -r choice
    case $choice in
        [Yy]*) return 0 ;;
        [Nn]*) return 1 ;;
    esac
}

############################## UTILITY ##############################  

#################### STRING ####################  

##
# converts a string to all lowercase characters
#
# @1      - the string to convert to lowercase
# @return - the string in all lowercase
##
to_lowercase() {
    res="$(echo "$1" | tr '[:upper:]' '[:lower:]')"
    printf '%s' "$res"
}

##
# determines whether or not a given string starts with a substr 
#
# @1      - the subtr to look for at the begining
# @2      - the string in which to search
# @return - true if the string starts with the substr, false otherwise
##
starts_with() {
    # match at the start of a line
    find_regex='^'"$1"

    res="$(echo "$2" | grep -Eo "$find_regex")"

    # empty response is no match
    if [ -n "$res" ]; then
        return 0
    fi
    return 1
}

##
# shorthand for repeating a string n number of times
# 
# @1      - the number of times to repeat the string
# @2      - the string to repeat
# @return - the string (@2) repeated @1 number of times
#           (eq to python str * num)
##
repeat_str() {
    res=''
    i=0
    while [ "$i" -lt "$1" ]; do
        res="$res""$2"
        i=$((i+1))
    done
    printf '%s' "$res"
}

#################### ARRAYS ####################  

##
# reads the given file into a space-separated string 'array'
#
# the function reads the given file into a string, replacing every encountered
# newline with a space. note: any spaces in the file will be interpreted as a
# new element in the 'array' 
#
# @1      - the file to read into an 'array'
# @return - the string 'array'
##
file_to_array() {
    filtered_content="$(tr '\n' ' ' < "$1")"

    printf '%s' "$filtered_content"
}

##
# checks whether or not a string is in an 'array'
#
# the function iterates through an 'array' of space separated elements and
# returns whether or not the given string is equal to any element in the 'array'
#
# @1      - the 'array' in which to search
# @2      - the string to search for in the 'array'
# @return - 0 if the string is in the 'array', 1 otherwise
##
in_array() {
    for element in $1; do
        if [ "$2" = "$element" ]; then
            return 0
        fi
    done
    return 1
}

##
# takes a file glob and a directory and returns the files that match the glob
# in the directory in the form of a space separated string.
# 
# @1      - the directory in which to search
# @2      - the glob to use in the directory
# @return - sh 'array' of the files that match the glob
##
collect_file_glob() {
    collected_files=''
    path_glob="$1"'/'"$2"

    for file in $path_glob; do
        collected_files="$collected_files"' '"$file"
    done

    if [ ! "${file# }" = "$path_glob" ]; then
        printf '%s' "$collected_files"
    else
        printf ''
    fi
}

#################### FILE SYSTEM ####################  

##
# correct a given path with an offset to the root level directory
#
# @1      - the path to correct
# @return - the corrected path 
##
submodule_path_correct() {
    if [ -z "$DDM" ]; then
        printf '%s' "$1"
    else
        num_above=$((DDM*2))
        above_relpath="$(repeat_str "$num_above" '../')"

        printf '%s%s' "$above_relpath" "$1"
    fi
}

##
# abstraction over caching the creation of a file/directory 
#
# @1 - the newly created file/directory to log
##
log_creation() {
    offset_dirs_file="$(submodule_path_correct "$CREATED_DIRS_CACHE_FILE")"
    offset_links_file="$(submodule_path_correct "$CREATED_FILES_CACHE_FILE")"

    if [ -d "$1" ]; then
        echo "$1" >> "$offset_dirs_file" 
    else
        echo "$1" >> "$offset_links_file"
    fi
}

##
# preemptive conflict detection and resolution
#
# the function first checks whether or not a file exists at a given
# destination. if the file does exist, it then checks the global $FORCE flag
# and returns true if it's set. otherwise, it prompts the user to overwrite it,
# returning true if the user would like to overwrite it, otherwise returning
# false. 
#
# @1      - the destination file to check
# @return - 0 for a successful resolution, 1 if a conflict could 
##
resolve_file_conflict() {
    if [ -e "$1" ]; then
        if in_array "$CREATED_FILES_CACHE" "$1"; then
            info "skipping '""$(basename "$1")""'; already installed"
            return 1
        fi

        if [ "$FORCE" -gt 0 ]; then
            warn "force enabled overriding '""$1""' with symlink"
            return 0
        else
            if ! prompt_conflict "$1"; then
                info "skipping '""$(basename "$1")""'"
                return 1
            fi
        fi
    fi
}

##
# create a symlink with the globally defined $LN
#
# the function links a given source to a given destination, logging the
# operation to the console for the user to read as well as logging the created
# destination to ddm's cache files for later removals.
#
# @1      - source file's path 
# @2      - the destination path 
# @return - 0 for link success, 1 for failure
##
logged_ln() {
    filename="$(basename "$1")"
    full_dest="$2"'/'"$filename"

    info "linking '""$1""' to '""$2"

    if $LN "$1" "$2"; then
        log_creation "$full_dest"
        return 0
    else
        error "cannot create symlink in '""$2""'" 
        return 1
    fi 
}

##
# copy a file to a destination and log a success
#
# @1      - the source path
# @2      - the destination path
# @return - 0 for a copy success, 1 otherwise
##
logged_cp() {
    filename="$(basename "$1")"
    full_dest="$2"'/'"$filename"

    info "copying '""$1""' to '""$2"

    if $CP "$1" "$2"; then
        log_creation "$full_dest"
        return 0
    else
        error "cannot copy '""$filename""'to '""$2""'"
        return 1
    fi
}

##
# create a directory if it doesn't exist already
#
# the function creates a directory if it doesn't exist, logging the newly
# created directory in ddm's cache files for later removals. the function
# notifies the user that it has created a new directory.
#
# @1      - the path of the directory to create
# @return - 0 on success, 1 for creation failure
##
create_dir_if_not_exists() {
    if [ ! -d "$1" ]; then
        info "creating directory '""$1""' to store config files" 

        if mkdir -p "$1"; then
            log_creation "$1"
            return 0
        else
            error "could not create install directory '""$1""'"
            return 1
        fi
    fi
    return 0
}

#################### FUNCTIONALITY ####################  

##
# load persistent files into memory for easier processing
##
load_persistent_files() {
    created_dirs_offset="$(submodule_path_correct "$CREATED_DIRS_CACHE_FILE")"
    created_links_offset="$(submodule_path_correct "$CREATED_FILES_CACHE_FILE")"

    if [ -e "$created_dirs_offset" ]; then
        # shellcheck disable=SC2034
        CREATED_DIRS_CACHE="$(file_to_array "$created_dirs_offset")"
    fi

    if [ -e "$created_links_offset" ]; then
        CREATED_FILES_CACHE="$(file_to_array "$created_links_offset")"
    fi

    if [ -e "$IGNORED_GLOBS_FILE" ]; then
        IGNORED_GLOBS="$(file_to_array "$IGNORED_GLOBS_FILE")"
    fi
}

##
# takes a given application name and returns whether or not it is a valid
# installation candidate 
#
# the function looks for an executable inst.sh file in the application directory
# relative to the current directory; if it finds the file, the function runs it
# with the global $SH, and returns its return value. otherwise, the function
# checks whether or not the application name is in the $PATH, and returns false
# if it cannot be found.
#
# @1      - the name of the application to verify
# @return - 0 if the application meets the criterion for install,
#           1 otherwise
##
can_install() {
    verify_script="$1"'/inst.sh'

    if [ -x "$verify_script" ]; then
        if $SH "$verify_script"; then
            return 0
        fi
    else
        if [ -n "$(command -v "$appname")" ]; then
            return 0
        fi
    fi
    return 1
}

##
# takes a file/directory name and returns whether or not it's in any of the
# ddmignore matches.
#
# @1      - the directory/file name to check against
# @return - 0 if the directory should be ignored, 1 otherwise 
##
is_ignored() {
    # shortcut - if there is no cache everything matches
    if [ -z "$IGNORED_GLOBS" ]; then
        return 1
    fi

    for ignore in $IGNORED_GLOBS; do
        if starts_with "$ignore" "$1"; then
            return 0
        fi
    done
    return 1
}

##
# installs an application with its installation properties
#
# the function sets up default installation properties, then allows the
# application's meta file to override them; the function then installs the
# application
#
# @1      - the name of the application to install
# @return - 0 for a successful install, 1 for any error
##
install_config() {
    # find meta script directory
    meta_script="$1"'/meta'

    # setup default install variables
    install_dir="$HOME""/.config/""$1"
    install_method="symlink"

    if [ -x "$meta_script" ]; then
        # shellcheck disable=SC1090
        . "$meta_script"
    fi

    # check installation properties for validity

    # check install directory 
    if ! create_dir_if_not_exists "$install_dir"; then
        return 1;
    fi

    # check install method
    if ! in_array "$VALID_INSTALL_METHODS" "$install_method"; then
        error "unrecognized install_method: '""$install_method""'"
        return 1
    fi

    info "installing '""$1""' configurations to '""$install_dir""'"

    # make sure config files exist
    conf_files_location="$1"'/conf'
    if [ ! -d "$conf_files_location" ]; then
        warn 'could not find config files for application '"$1"
        return 1
    fi

    # var for list of conf files
    conf_files=''

    # normally globs don't match dotfiles - so we need two passes, once to 
    # pick up the dotfiles, another to pick up any other files
    conf_files="$(collect_file_glob "$conf_files_location" "$DOTFILES_GLOB")"
    conf_files="$conf_files""$(collect_file_glob "$conf_files_location" '*')"

    # store install function for repeated use
    install_fn=''
    if [ "$install_method" = "symlink" ]; then
        install_fn=logged_ln
    elif [ "$install_method" = "copy" ]; then
        install_fn=logged_cp
    fi

    # iterate through files linking to the right location
    for to_copy in $conf_files; do
        to_copy_name="$(basename "$to_copy")"
        destination="$install_dir"'/'"$to_copy_name"

        if ! resolve_file_conflict "$destination"; then
            continue
        fi

        $install_fn "$to_copy" "$install_dir"
    done
}

##
# processes submodules by creating a child instance of ddm
#
# handles setting the DDM environment variable, then makes another ddm instance
# in the given submodules folder.
#
# @1 - path of the submodules directory
##
process_submodules() {
    # get path of current executing script for instantiating
    # a new child instance
    cur_script_path="$(realpath "$0")"

    # set DDM if it doesn't exist
    [ -z "$DDM" ] && DDM=0

    # increment depth counter
    DDM=$((DDM+1))

    # export ddm for child
    export DDM

    # change directory into submodule
    cd "$sub_folder" || { error 'could cd into submodule'; return 1; } 

    # call child instance
    $SH "$cur_script_path"

    # exit directory of submodule
    cd '../..'

    # decrement ddm 
    DDM=$((DDM-1))

    # unset if le 0 to prevent negative DDM
    [ "$DDM" -le 0 ] && unset DDM
    
    # export just in case
    export DDM
}

############################## SUBCOMMANDS ##############################  

##
# installs all application packages in the given directory by first checking if
# they can be installed, then running the install_config command on them; this
# is the main driver behind all application configuration installation
##
install() {
    load_persistent_files

    for folder in $(collect_file_glob '.' '*/'); do
        appname="$(basename "$folder")"

        if is_ignored "$folder"; then
            info "skipping '""$appname""'; excluded in ddmignore"
            continue
        fi

        # if we can't install, just skip over
        if ! can_install "$appname"; then
            warn "skipping '""$appname""'; not applicable"
            continue
        fi

        install_config "$appname"

        # store submodule folder
        sub_folder="$folder"'sub'

        if [ -d "$sub_folder" ]; then # make a recursive call
            info "installing submodules for '""$appname""'"
            process_submodules "$sub_folder"
        fi
    done
}

##
# uses the corresponding cache files to remove the installed symlinks and
# folders, first removing the symlinks, then removing the empty folders that
# remain (and leaving the ones that aren't empty)
##
uninstall() {
    # if no cache files exist we should warn the user about it and exit
    if [ ! -f "$CREATED_FILES_CACHE_FILE" ] && [ ! -f "$CREATED_DIRS_CACHE_FILE" ]; then
        error 'cache files do not exist; are you sure you installed?'
        return 1
    fi

    # remove cached created symlinks
    if [ -f "$CREATED_FILES_CACHE_FILE" ]; then
        # shellcheck disable=SC2013
        for created_file in $(cat "$CREATED_FILES_CACHE_FILE"); do
            if [ -e "$created_file" ]; then
                info 'removing file "'"$created_file"'"'
                rm "$created_file"
            fi
        done
    fi


    # remove empty created folders
    if [ -f "$CREATED_DIRS_CACHE_FILE" ]; then
        # shellcheck disable=SC2013
        for created_folder in $(cat "$CREATED_DIRS_CACHE_FILE"); do
            # attempt to remove
            $RMDIR "$created_folder"

            # check if remove worked and inform user
            if [ -d "$created_folder" ]; then
                warn 'could not remove directory "'"$created_folder"'"; not empty'
            else
                info 'removed directory "'"$created_folder"'"'
            fi
        done
    fi

    rm -f "$CREATED_DIRS_CACHE_FILE" "$CREATED_FILES_CACHE_FILE"
}

############################## CLI PROCESSING ##############################  

# if testing return instead of exit
[ -n "$DDM_TEST" ] && return 0;

# if parent set DDM_ARGS for children
[ -z "$DDM_ARGS" ] && { DDM_ARGS="$*"; export DDM_ARGS; }

# if child 'import' ddm definitions from parent
# shellcheck disable=SC2086
[ -n "$DDM" ] && { set $DDM_ARGS; }

# print usage info with no arguments 
if [ $# -lt 1 ]; then usage && exit 1; fi

# help shortcut - subcommand processing would ordinarily prevent help flags 
if [ "$1" = '-h' ] || [ "$1" = '--help' ]; then usage && exit 0; fi

# parse command line options
subcommand=$1; shift
while getopts "fvVh" opt; do
    case $opt in
        f )
            FORCE=1
        ;;
        v )
            VERBOSE=1
        ;;
        h )
            usage
            exit 0
        ;;
        ? )
            error 'Unknown option'
            usage
            exit 1
        ;;
    esac
done

# process subcommands
if [ "$subcommand" = "install" ]; then
    install
elif [ "$subcommand" = "uninstall" ]; then
    uninstall
else
    error "'""$subcommand""'"" is not a ddm command. See 'ddm -h'."
    exit 1
fi
